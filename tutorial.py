# -*- coding: utf-8 -*-
"""Tutorial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fNig1VaE1HcYWqXn3Q5jaxHf-fULR8r9
"""

# two ways to reverse the list or array
# using [::-1]
# and using reverse()

ListToReverse = [1,2,4,3,7,5]
R = ListToReverse[::-1]
print (R)


ListToRev = [9,89,2,4,13,7,5]
ListToRev.reverse()
print (ListToRev)

# use of    all
# use of    sort()
# use of    round()
# use of    bin() oct() hex()
# use of    items()          -   prints all the elements of dictionary

def printPrime():
  for num in range (100,200):
    if all(num % i != 0 for i in range(2,num)):
      print(num, end = ',')
printPrime()

print(end='\n')
print('#############################################################################')
print(end='\n')

#  sort() 

listToSort = ['a','bb','dddd','ccc']
listToSort.sort()
print(listToSort)

print(end='\n')
print('#############################################################################')
print(end='\n')

# round()

def to_round_of(num):
    result = round(num,3)
    # return result
    print (result)

to_round_of(2.45677)

print(end='\n')
print('#############################################################################')
print(end='\n')

# bin() similarily we can apply oct(), hex()

def convert(num):
   base2_num = bin(num)
   # return base2_num
   print(base2_num)

convert(5)

print(end='\n')
print('#############################################################################')
print(end='\n')

# items ()  printing all the elements of dictionary

person2 = {'name':'sss', 'city1':'bhilai', 'phno1':8788900} 
for i in person2.items():
    print(i)

# list & dictionary comprehention
# its a way of transforming the list or dictionary

lst = [1,3,6,7,8,9,22]

lst_comp = [x*2 for x in lst]
print(lst_comp)

# dict comprehension

dict_comp = { x:x**2 for x in lst}
print(dict_comp)

# lambda is an annonymus function that can take multiple argument

mul = lambda a,b : a*b
print(mul(2,3))

#  *args      is used when we dont know how many arguments can be passed to the fumction
#  **args     is used when we dont know how many arguments can be passed to the fumction
#             and this will give the result with key

def func(*var):
   for i in var:
       print(i)

func(1)
func(20,1,6)

# another example

def person3(name, *data):
  print(name)
  print(data)

person3('sss', 'raipur', 8788900)

print(end='\n')
print('#############################################################################')
print(end='\n')

def person(name, **data):
  print(name)
  print(data)

person('sss', city1='raipur', phno1=8788900) 

# another way

def person1(name, **data1):
  print(name)
  for i,j in data1.items():
    print(i,j)

person1('sss', city1='bhilai', phno1=8788900)

# types of function

# 1 instance function

class student:

  school = 'csvtu'   # its static variable defined outside the init method

  def __init__(self,m1,m2,m3):
    self.m1 = m1
    self.m2 = m2
    self.m3 = m3

  def avg(self):      # its instance function
    return (self.m1 + self.m2 +self.m3)/3

s1 = student(45,78,65)
s2 = student(35,98,98)

print(s1.avg())
print(s2.avg())

# types of function

# 2 class function

# class functions are used to work with the class variables 
# e.g here if we change the name of the school it shd be changed for all the instances of the class

class student:

  school = 'csvtu'   # its static variable defined outside the init method

  def __init__(self,m1,m2,m3):
    self.m1 = m1
    self.m2 = m2
    self.m3 = m3

  def avg(self):      # its instance function
    return (self.m1 + self.m2 +self.m3)/3

  @classmethod        # to make the class method we use @classmethod decorator
  def get_school(cls):      # since we hv to work with the class variable here, we pass self instead of self
    return cls.school


s1 = student(45,78,65)
s2 = student(35,98,98)

print(s1.avg())
print(s2.avg())

print(student.get_school())

# types of function

# 3 static function

# 


class student:

  school = 'csvtu'   # its static variable defined outside the init method

  def __init__(self,m1,m2,m3):
    self.m1 = m1
    self.m2 = m2
    self.m3 = m3

  def avg(self):      # its instance function
    return (self.m1 + self.m2 +self.m3)/3

  @classmethod        # to make the class method we use @classmethod decorator
  def get_school(cls):      # since we hv to work with the class variable here, we pass self instead of self
    return cls.school

  @staticmethod
  def info():         # this method has nothing to do with either class var or instance var therefore we hv not passed self or cls
    print('this is class student')

s1 = student(45,78,65)
s2 = student(35,98,98)

print(s1.avg())
print(s2.avg())

print(student.get_school())

#  slicing

from array import *
arr = array('i',[11,22,33,44,5,66,77,45,34,23])

#     sum(), count(), index(), min() and max() functions of List

numbers = [1, 2, 3, 4, 1, 3, 6, 8, 3]
print(sum(numbers))

print(numbers.count(4))

print(numbers.index(4))

print(min(numbers))

print(len(numbers))

#   global & globals()

global a 
a = 10

def l_var():
  a = 15
  print("local var",a)

l_var()

def g_var():
  # global a
  a = 15
  print("local var",a)

g_var()

print(a)

#   serializer

#   JSON   :    python has built in package called "JSON" that works with the JSON data

#   dumps(data)  :  converts python objects into JSON string

#   loads(data)  : used to parse JSON string  i.e. reverse of dumps

#   serializers converts complex data such as queryset models into python data that can be understtod by front-end
#   deserialization   reverse of serialization



#   cache :  it provides temporary storage of web document to reduce the server lag and makes the website faster
#   per-site cache (when we cache the entire site)
#   per-view cache (it cache the output of individual view)
#   template fragment cache ( this gives u more control about what to cache)



#   model inheritance  :  model subclass should be inherited from the django..db.models.Model
#                         1. abstract base classes
#                         2. multi table inheritance
#                         3. proxy inheritance


#   signals   :     allows to associate events with actions. 


#   authentication  :  django provides both authentication and authorization both & together it referred to as authentication system
#                      its already there in settings.py  in INSTALLED APP 
#                       django.contrib.auth
#                       django.contrib.contenttypes

#  counter in python

# finding common characters

# counter function counts each element of the list 

import collections

def match(lst):
  result = collections.Counter(lst[0])
  for i in lst:
    result &= collections.Counter(i)
  return list(result.elements())

lst = ['mango', 'appleo','pinappleo','bananao']
match(lst)